#---------------------------------------------------------------------------------------------
# Name: HabitatAssociations.R
# Purpose: THis script takes a list of species/habitat associations (generated by extract 
#          by values in ArcGIS) and compares these observed proportions to expected values 
#          (which in this case is the relative proportion of each habitat type in the project
#          area generated by a Tabulate Area command)
# Author: Christopher Tracey
# Created: 2016-02-12
# Updated: 2016-06-13
#
# Updates:
# insert date and info
# * 2016-02-22 - cleaned up the code and documentation
# * 2016-06-13 - rewrote the code to deal with the NatureServe format and other issues
#
# To Do List/Future Ideas:
# * bootstrapping
# * compact the code up a little.
#---------------------------------------------------------------------------------------------

# load in the 'reshape' and 'data.table' packages
library(reshape)
library(data.table)
library(beanplot)
library(plyr)

### Load the package or install if not present
if (!require("RColorBrewer")) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}

#######################################################################################################
# reads the habitat proportions in
# data should be a csv file with the following format: ES_NAME,area_meters,acres,proportion
habitat <- read.csv("A1_Habitat_DSLDistanceNew.csv", na.strings=c("NA"))

# pick one of the following to process the habitat raster
habitat$habitatcode <- paste(habitat$BaseHabitatData1,habitat$BaseHabitatData2, sep="_")
habitat$habitatcode <- paste(habitat$BaseHabitatData1,habitat$BaseHabitatData2,habitat$BaseHabitatData3, sep="_")
# pick on of the above  
habitat <- habitat[,!(names(habitat) %in% c("OBJECTID","VALUE"))] #drop a few unneeded columns

# this counts the 'expected' values for the analysis. Basicaally calculates a proportion
habitat$expected <- habitat$Count / sum(habitat$Count)
# this gets down to a unique set of habitat codes as having duplicates seems to upset the merge below.
habitat_filter <- subset(habitat, !duplicated(habitatcode)) # this step might not be necessary


#######################################################################################################
# reads in the species occurence data as delivered by NatureServe
# data should be a csv file with the followign format:
# OBJECTID,EO_ID,ELCODE,EO_NUM,SNAME,SCOMNAME,ELSUBID,ID_CONFIRM,LASTOBS,SURVEYDATE,EORANK,GRANK,SRANK,USESA,SPROT,PBSSTATUS,PBSQUAL,SWG_STATUS,SWGCOM,EO_TYPE,SITE_NAME,SURVEYSITE,EO_TRACK,SENSITV_SP,SENSITV_EO,EO_DATA,GEN_DESC,EORANKCOM,MGMT_COM,GENERL_COM,PREC_BCD,EST_RA,QUAD_FILE,ER_RULE,X,Y,LEAD_RESP,MOD_BY,MOD_DATE,MAPPEDBY,MAPPEDDATE,EXPT_DATE,RASTERVALU,ES_NAME
# the only really important fields above are 'SNAME' and 'ES_NAME'   ****NEED TO UPDATE THIS COMMENT BLOCK!!!****
species = read.csv("SF_NS_test.csv", na.strings=c("NA"))
# reads in the Distance to Water table (update including oceans) and joins in to the table
distance2water <- read.csv("distance2water.csv", na.strings=c("NA"))
distancesonly <- distance2water[,c("SHAPE_JOIN","RASTERVALU")]
distancesonly$RASTERVALU <- as.integer(distancesonly$RASTERVALU)
names(distancesonly)[names(distancesonly)=="RASTERVALU"] <- "DISTANCE"
# the next line reclasses the distances into new categories using the cut function -- this is cool!
distancesonly$DISTANCE_CAT <- cut(distancesonly$DISTANCE, breaks=c(-Inf, 100, 300, 1000, Inf),
                     labels=c("100","300","1000","1001")) # "<100","100-300","300-1000",">1000"
species=join(species,distancesonly,by=c('SHAPE_JOIN'))


# Drop columns that are not as needed for this analysis or ones that are duplicates.
species1 <- species[,!(names(species) %in% c("OBJECTID_1","EORANK_DATE","SUBNATION_1"))]
# subsets to only include the animals ---- change "A" to "P" for Plants.
species1 <- droplevels(subset(species1,SPECIES_TYPE_1=="A"))
# deletes all the extirpated and historics at the EO level.
 species1 <- droplevels(subset(species1,EORANK!="X" & EORANK!="X?" &  EORANK!="H" & EORANK!="H?"))
# delete any EO update that's older than a 19XX
species1$EO_LASTOBS_YEAR <- as.numeric(as.character(species1$EO_LASTOBS_YEAR)) 

# picks the most recent year between the EO and the SF.  They may be be slightly incorrect...
species1$SF_VISIT_YEAR <- as.numeric(as.character(species1$SF_VISIT_YEAR)) # creates a bunch 
    # of NAs for all the wierd date values
species1$LASTYEAR <- ifelse(!is.na(species1$EO_LASTOBS_YEAR)>!is.na(species1$SF_VISIT_YEAR), 
    species1$EO_LASTOBS_YEAR, species1$SF_VISIT_YEAR) 

# subsets the species data to the most recent 30 years of data
species_final <- subset(species1,LASTYEAR>=1986)
# renames the habitat GRIDCODE field
# names(species_final)[names(species_final)=="gridcode"] <- "habitatcode" #this might be better to make a new field
species_final$habitatcode <- paste(species_final$gridcode,species_final$DISTANCE_CAT, sep="_")

##############################################################################################
# I think any bootstrapping or subset selection needs to be placed around here
# Need to investigate this some more
##############################################################################################


##############################################################################################
# turns the data frame into a table of counts and calculate proportions. 
# the margin setting in prop.table adds row summaries of the individual habitat proportions

count_table <- table(species_final$GNAME_1,species_final$habitatcode) # turns the raw data into a table of counts
prop_table <- prop.table(count_table,margin=1) # adds column? summaries
prop_table <- addmargins(prop_table,margin=2) #adds row? summaries

# convert prop_table into a dataframe
occ_prop <- as.data.frame.matrix(prop_table) 
occ_prop <- cbind(row.names = rownames(occ_prop), occ_prop) # adds the row names into the data frame
setDT(occ_prop, keep.rownames = TRUE)[]

# this transforms the data into a table with one entry per species and habitat combination, this makes
#    the calculatations a little easier (eg. less matrix math)
results_melt <- melt(occ_prop, id="rn")
setnames(results_melt,"variable","habitatcode") 
setnames(results_melt,"value","observed")
data_merge <- merge(results_melt,habitat_filter,by="habitatcode",all=TRUE) # , allow.cartesian=TRUE

#calculates th observed minus expected values
data_merge$minus <- (((data_merge$observed - data_merge$expected)/data_merge$expected)+1)


# creates a habitat LookUp table for the weighing below
lu_habitat <- species_final[,c("habitatcode","hab_class_name")]
lu_habitat <- subset(lu_habitat, !duplicated(habitatcode))

# this sums up the values by habitat. Can change to any weighting method we want
habitat_weights <-aggregate(data_merge$minus, by=list(data_merge$habitatcode), FUN=sum, na.rm=TRUE)
names(habitat_weights)[names(habitat_weights)=="Group.1"] <- "habitatcode"
names(habitat_weights)[names(habitat_weights)=="x"] <- "weight"
habitat_weights=join(habitat_weights,lu_habitat,by=c('habitatcode'))



#########################################################################################
# Make some plots for fun
#dfEOlastyear <- unique(species1[,c("SOURCE_FEATURE_ID","LASTYEAR")])
#dfEOlastyear$LASTYEAR <- as.numeric(as.character(dfEOlastyear$LASTYEAR))
#dfEOlastyear$LASTYEAR <- factor(dfEOlastyear$LASTYEAR)
#dfEOlastyear$LASTYEAR <- as.numeric(as.character(dfEOlastyear$LASTYEAR))
#plot(dfEOlastyear$LASTYEAR,col=brewer.pal(5,"Set3"), 
 #    main="Number of Source Features by Year", xlab="year", ylab="# source features", ylim=g_range) 
